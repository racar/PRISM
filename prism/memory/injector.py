from __future__ import annotations

from datetime import date, timedelta
from pathlib import Path
from typing import Optional

from prism.memory.schemas import Skill
from prism.memory.store import SkillStore

_HEADER = """\
<!-- AUTO-GENERATED BY PRISM inject — DO NOT EDIT MANUALLY -->
<!-- Generated: {date} | Budget used: {used}/{budget} tokens -->

## Injected PRISM Context
"""

_SKILL_BLOCK = """\
### {skill_id} — {title}
**Type:** {type} | **Tags:** {tags} | **Uses:** {uses}
{summary}
→ `{path}`
"""


def count_tokens(text: str) -> int:
    try:
        import tiktoken
        return len(tiktoken.get_encoding("cl100k_base").encode(text))
    except ImportError:
        return len(text) // 4


def _recency_score(last_used: Optional[date]) -> float:
    if last_used is None:
        return 0.1
    days = (date.today() - last_used).days
    if days <= 30:
        return 1.0
    if days <= 90:
        return 0.5
    return 0.2


def _tag_match_score(skill_tags: list[str], query_tags: set[str]) -> float:
    if not query_tags:
        return 0.0
    return len(set(skill_tags) & query_tags) / len(query_tags)


def _rank_score(skill: Skill, query_tags: set[str]) -> float:
    fm = skill.frontmatter
    recency = _recency_score(fm.last_used)
    tag_match = _tag_match_score(fm.domain_tags, query_tags)
    return (fm.reuse_count * 2) + (recency * 1.5) + (tag_match * 3)


def _extract_summary(content: str, max_lines: int = 3) -> str:
    lines = [l for l in content.splitlines() if l.strip() and not l.startswith("#")]
    return " ".join(lines[:max_lines])[:200]


def _format_skill_block(skill: Skill) -> str:
    fm = skill.frontmatter
    path = str(skill.file_path) if skill.file_path else f"~/.prism/memory/{fm.subdir()}/{fm.skill_id}.md"
    return _SKILL_BLOCK.format(
        skill_id=fm.skill_id, title=skill.title, type=fm.type,
        tags=", ".join(fm.domain_tags), uses=fm.reuse_count,
        summary=_extract_summary(skill.content), path=path,
    )


def _select_within_budget(ranked: list[Skill], budget: int) -> tuple[list[Skill], int]:
    selected, used = [], 0
    for skill in ranked:
        block = _format_skill_block(skill)
        tokens = count_tokens(block)
        if used + tokens > budget:
            break
        selected.append(skill)
        used += tokens
    return selected, used


def inject_skills(
    store: SkillStore,
    query: str,
    query_tags: set[str],
    output_path: Path,
    budget: int = 4000,
) -> int:
    results = store.search(query, top_k=50) if query else []
    skills_from_search = [r.skill for r in results]

    all_active = store.list_all(status="active")
    seen = {s.frontmatter.skill_id for s in skills_from_search}
    extra = [s for s in all_active if s.frontmatter.skill_id not in seen]

    ranked = sorted(
        skills_from_search + extra,
        key=lambda s: _rank_score(s, query_tags),
        reverse=True,
    )
    selected, used_tokens = _select_within_budget(ranked, budget)

    header = _HEADER.format(date=date.today(), used=used_tokens, budget=budget)
    blocks = [_format_skill_block(s) for s in selected]
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(header + "\n".join(blocks))
    return len(selected)
