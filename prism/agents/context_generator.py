from __future__ import annotations

from datetime import date
from pathlib import Path

_TOOL_OUTPUT: dict[str, str] = {
    "claude_code": "CLAUDE.md",
    "opencode": "AGENTS.md",
    "cursor": ".cursorrules",
    "gemini": "GEMINI.md",
    "windsurf": ".windsurfrules",
    "copilot": ".github/copilot-instructions.md",
}

_HEADER = """\
<!-- AUTO-GENERATED BY PRISM — DO NOT EDIT MANUALLY -->
<!-- Source: .prism/PRISM.md | Tool: {tool} | Generated: {date} -->

"""

_STATE_BLOCK = """\

## Current Project State

- **Phase:** {phase}
- **Current task:** {task}
- **Memory:** {memory}
"""

_PERMISSIONS_BLOCK = """\

## File Access Permissions

✅ **AUTOMATIC READ PERMISSION GRANTED**

You have automatic permission to read files in this project WITHOUT asking for explicit confirmation. Simply use the file reading tools (Read, Glob, Grep) directly when you need to understand the codebase.

### Automatically Allowed Files:
- Source code (*.py, *.js, *.ts, *.tsx, *.jsx, etc.)
- Configuration files (*.json, *.yaml, *.yml, *.toml, .env.example)
- Documentation (*.md, *.txt)
- Style files (*.css, *.scss)
- HTML files
- PRISM config (.prism/**/*)
- Test files (tests/**/*, specs/**/*)

### Protected Files (Require Explicit Permission):
- Secrets (.env*, *.key, *.pem, credentials/**/*)
- Private keys (.ssh/**/*)
- Large directories (node_modules/**, .git/**, dist/**, build/**)
- Binary files and build outputs

### Usage:
```
Read("src/main.py")
Glob("src/**/*.ts")
Grep("function", path="src/")
```

Proceed with confidence when reading files to understand and work with the codebase.
"""


def output_file_for_tool(tool: str) -> str:
    return _TOOL_OUTPUT.get(tool, "CLAUDE.md")


def is_manually_edited(path: Path) -> bool:
    if not path.exists():
        return False
    return "AUTO-GENERATED BY PRISM" not in path.read_text(encoding="utf-8")[:200]


def generate_context_file(tool: str, project_dir: Path) -> Path:
    out_rel = output_file_for_tool(tool)
    out_path = project_dir / out_rel
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(_build_content(tool, project_dir), encoding="utf-8")
    return out_path


def _build_content(tool: str, project_dir: Path) -> str:
    header = _HEADER.format(tool=tool, date=date.today())
    prism_md = _read_file(project_dir / ".prism" / "PRISM.md")
    injected = _injected_section(project_dir)
    state = _state_section(project_dir)
    permissions = _permissions_section()
    return header + prism_md + injected + state + permissions


def _permissions_section() -> str:
    return _PERMISSIONS_BLOCK


def _read_file(path: Path, default: str = "") -> str:
    return path.read_text(encoding="utf-8") if path.exists() else default


def _injected_section(project_dir: Path) -> str:
    content = _read_file(project_dir / ".prism" / "injected-context.md")
    return ("\n\n" + content) if content else ""


def _state_section(project_dir: Path) -> str:
    has_task = (project_dir / ".prism" / "current-task.md").exists()
    mem_path = Path.home() / ".prism" / "memory"
    phase = "in-progress" if has_task else "planning"
    task = "see .prism/current-task.md" if has_task else "none active"
    skill_count = len(list(mem_path.glob("**/*.md"))) if mem_path.exists() else 0
    memory = f"{skill_count} skills in ~/.prism/memory/"
    return _STATE_BLOCK.format(phase=phase, task=task, memory=memory)
